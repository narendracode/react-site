{"version":3,"sources":["webpack:///path---blog-8b4db292968afd4e1229.js","webpack:///./.cache/json/blog.json"],"names":["webpackJsonp","532","module","exports","data","site","siteMetadata","title","description","url","author","twitter","remark","posts","post","html","frontmatter","layout","path","categories","tags","date","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,SAAAC,YAAA,sCAAAC,IAAA,sDAAAC,OAAA,WAAAC,QAAA,aAA2KC,QAAWC,QAAUC,MAAQC,KAAA,22OAAAC,aAAu4OC,OAAA,OAAAV,MAAA,8CAAAW,KAAA,iDAAAC,YAAA,sCAAAC,MAAA,wCAAAZ,YAAA,mZAAAa,KAAA,iBAA2pBP,MAAQC,KAAA,qynBAA8ljBC,aAA69EC,OAAA,OAAAV,MAAA,0DAAAW,KAAA,gEAAAC,YAAA,UAAAC,MAAA,8CAAAZ,YAAA,m6BAAAa,KAAA,mBAAqsCC","file":"path---blog-8b4db292968afd4e1229.js","sourcesContent":["webpackJsonp([49683490770531],{\n\n/***/ 532:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Gatsby\",\"description\":\"Gatsby starter for bootstrap a blog\",\"url\":\"https://jaxx2104.github.io/gatsby-starter-bootstrap\",\"author\":\"Narendra\",\"twitter\":\"narendra\"}},\"remark\":{\"posts\":[{\"post\":{\"html\":\"<p>When starting out as a web developer, it can be easy to get lost in the multitude of languages, tools and platforms that are available in today’s market. However many would argue that GitHub is an essential platform for every web developer at every level.</p>\\n<p>GitHub was launched in April 2008 by Tom Preston-Werner, Chris Wanstrath, and PJ Hyett. At its base, it is a web platform, written in Ruby on Rails and Erlang, which hosts code repositories. But it also provides developers with an amazing toolset that makes it easy to follow certain coding best practices, all the while allowing you to get your name out there and show what you are capable of doing.</p>\\n<p>In this article, I will explain why GitHub is such an important tool for today’s web developer and how you can go about using it to get your name out there and advance your career in web development.</p>\\n<p><img src=\\\"/images/github.png\\\" alt=\\\"alt text\\\" title=\\\"Github\\\"></p>\\n<hr>\\n<h2>GitHub Makes Version Control Easier</h2>\\n<p>Few coding best practices are as prevalent as having some sort of Version Control for your code. Whether you are developing in Ruby, JavaScript, Python or any other language, a good Version Control workflow is essential and GitHub makes implementing that workflow easier by giving developers great tools with which to work.</p>\\n<p>As mentioned before, GitHub hosts Git repositories. Git is an immensely popular Version Control System, which allows developers to create a history of changes that occur over time in their code.</p>\\n<blockquote>\\n<p><strong>GitHub also adds several of its own functionalities to the ones offered by Git, such as::</strong></p>\\n<ul>\\n<li>A web-based graphical interface</li>\\n<li>A pastebin style site named Gist</li>\\n<li>Great tools for collaborating with other developers</li>\\n</ul>\\n</blockquote>\\n<h2>Graphical Interface</h2>\\n<p>Git is very powerful, but it can only be used in the terminal, which can be daunting for many developers, especially new developers. Viewing logs and differentials between commits can be very difficult to do in a purely command-prompt interface.</p>\\n<p>GitHub creates an intuitive and powerful graphical interface for the Git versioning system. You can easily see your repositories and browse through its list of commits. If you want to see the changes made in one of your commits, it is as simple as clicking on the commit from the list and GitHub will present you with the differential. Much simpler than typing commands in your terminal and deciphering their results.</p>\\n<p>Above is an example from a user in GitHub.</p>\\n<p>Create a profile, upload some code and see how things are laid out, it is very user friendly and intuitive.</p>\\n<h2>Gist</h2>\\n<p>Pastebin applications allow users to store plain text. They are commonly used by developers to store and share small scripts and bits of codes. Gist was created by GitHub as a Pastebin-style application, but Gists also benefit from Version Control.</p>\\n<p>Each Gist is essentially a mini-project, it has its own Git repository, which allows users to store multiple bits of code and also allows them to track changes within their Gist, without needing to commit them manually.</p>\\n<p>Gist are by default public, to make it easier to share, but they can also be marked as private, allowing only you to access them.</p>\\n<h2>Collaboration Tools</h2>\\n<p>Github also introduces many collaboration tools, some of which are listed below, which make it easier for developers to work together on a project.</p>\\n<ol>\\n<li>GitHub allows you to create access rights to your code which means, for example, you could designate certain users who are allowed to freely push code to your repository.</li>\\n<li>GitHub’s Forking feature allows a user to create a copy of a repository on their computer for them to work on without affecting the main repository. They can modify the code and then request to have the code merged with the main repository using another feature called Pull Requests.</li>\\n<li>Pull Requests are a way for you to tell other developers about the changes you wish to merge into the main repository. The repository’s authors can review your changes and engage in discussions about them. Should more changes be needed, you can simply continue to work in your fork and the additional commits will appear in the pull request. Once a Pull Request is approved, the changes can then be merged into the main repository by the project’s author.</li>\\n<li>GitHub also has Issues for repositories. Issues are a great way to keep track of bugs in your code, but you can also use it to keep track of tasks and other enhancements you would like to implement in your code. Issues are very powerful and mastering them is a great way to keep yourself organised. For more information on Issues, please see this guide posted on GitHub’s website.</li>\\n</ol>\\n<h2>GitHub Is The Place To Be For Open Source</h2>\\n<p>With so many great tools available to developers, GitHub has become the place to be for open source software. Some of the biggest open source projects are hosted on GitHub, such as Ruby on Rails, AngularJS, Bootstrap and many many more. There are even some big tech companies, like Microsoft, who maintain code repositories on GitHub.</p>\\n<p>The collaboration features mentioned above make it easy for any developer to get involved with their favorite open source project.</p>\\n<p>GitHub also allows you to keep an eye on your favorite developers by following them or your favorite project by “watching” it. There are many ways to be social on GitHub, so don’t hesitate to go exploring and see what is happening in the world of software development.</p>\\n<h2>Using GitHub To Showcase Your Skills</h2>\\n<p>As we have mentioned above, GitHub is a great tool to make Version Control easier and it’s a site that is used for some of the biggest projects out there. But perhaps it’s biggest asset is the fact that it is a great way to showcase your skills.</p>\\n<p>A GitHub profile that features real world projects and shows contributions to open source projects is a great way to display exactly what you are capable of doing to prospective employers.</p>\\n<p>When applying to developer positions, employers are looking for people who have experience programming and who program well. You can direct prospective employers to your GitHub profile, which can act as your portfolio. Employers can then:</p>\\n<ul>\\n<li>view your code</li>\\n<li>see how you think</li>\\n<li>understand how you solved particular problems</li>\\n<li>see whether or not you would be a good fit for their organization. Your open source contributions can also show potential employers that you are versatile and can easily adapt and contribute to various projects, something that is essential when working as a web developer.</li>\\n</ul>\\n<p>Having a fully fleshed out and varied GitHub profile is a great way to stand out as a web developer in today’s market.</p>\\n<p>GitHub has become one of the few necessary platforms to use in today’s web development world. It is a great tool that makes your life easier, has the potential to make you stand out from other web developers and hosts some of the biggest and most interesting projects out there today. So I recommend you go out and explore the various projects on GitHub and start contributing to your favourite ones.</p>\\n<p>Interested in launching a career in web development? Don’t forget to check out CareerFoundry’s Web Development Course too.\\nHappy coding!</p>\",\"frontmatter\":{\"layout\":\"post\",\"title\":\"The Importance of GitHub for Web Developers\",\"path\":\"/blog/importance-of-github-for-web-developers/\",\"categories\":[\"programming\",\"software-development\"],\"tags\":[\"developers\",\"web-developers\",\"github\"],\"description\":\"GitHub was launched in April 2008 by Tom Preston-Werner, Chris Wanstrath, and PJ Hyett. At its base, it is a web platform, written in Ruby on Rails and Erlang, which hosts code repositories. But it also provides developers with an amazing toolset that makes it easy to follow certain coding best practices, all the while allowing you to get your name out there and show what you are capable of doing.\",\"date\":\"2017/12/19\"}}},{\"post\":{\"html\":\"<p>In this guide, i will be taking you through the complete process of setting up CI,CD using <a href=\\\"http://github.com\\\" target=\\\"_blank\\\"> Github </a>, <a href=\\\"https://www.docker.com\\\" target=\\\"_blank\\\">Docker</a>, <a href=\\\"https://travis-ci.org\\\" target=\\\"_blank\\\"> TravisCI</a>, <a href=\\\"https://cloud.docker.com\\\" target=\\\"_blank\\\">Docker Cloud</a> and <a href=\\\"https://www.digitalocean.com\\\" target=\\\"_blank\\\">DigitalOcean</a>.\\nIf you are not familiar with CI/CD then i highly encourage you to please go through <a href=\\\"https://www.digitalocean.com/community/tutorials/an-introduction-to-continuous-integration-delivery-and-deployment\\\" target=\\\"_blank\\\">this</a> article. Once you have basic idea about CI/CD, i promise you that you will be successful in automating your build and deployment process.</p>\\n<p>I assume you have accounts in <a href=\\\"http://github.com\\\" target=\\\"_blank\\\"> Github </a>, <a href=\\\"https://travis-ci.org\\\" target=\\\"_blank\\\"> TravisCI</a>, <a href=\\\"https://cloud.docker.com\\\" target=\\\"_blank\\\">Docker Cloud</a> and <a href=\\\"https://www.digitalocean.com\\\" target=\\\"_blank\\\">DigitalOcean</a>. In case you don't have accounts yet then please create one. I am using <strong>DigitalOcean</strong> for running docker nodes and servies. DigitalOcean offers all the necessary services at reasonable price for running production apps. You can go with the very basic <strong>Ubuntu 16.04.3 x64 $5/mo droplet</strong>, it will give you <strong>512mb/1CPU 20GB SSD hard disk</strong>, which is good enough for running our app.</p>\\n<p>You can follow <a href=\\\"https://www.wikihow.com/Create-an-Account-on-GitHub\\\" target=\\\"_blank\\\">these steps</a> to create an account in <strong>Github</strong>.</p>\\n<p><strong>Travis CI</strong> is a hosted, distributed continuous integration service used to build and test software projects hosted at GitHub. Open source projects may be tested at no charge via <a href=\\\"https://travis-ci.org\\\">https://travis-ci.org</a> . </p>\\n<p><img src=\\\"/images/ci-cd.png\\\" alt=\\\"alt text\\\" title=\\\"CI/CD\\\"></p>\\n<p>In this guide i am using my <a href=\\\"https://github.com/narendrasoni1989/react-site\\\" target=\\\"_blank\\\">sample portfolio project </a>hosted in Github. It is developed using revolutionary high performance site generator framework <a href=\\\"https://www.gatsbyjs.org/\\\" target=\\\"_blank\\\">GatsbyJs</a>. It's an amazing platform if you want to build your application. It is based on <a href=\\\"https://jamstack.org/\\\" target=\\\"_blank\\\">JAMStack</a>. Do checkout if you are interested to build your portfolio. Feel free to use my sourcecode if you are interested. To Please follow the <a href=\\\"https://www.gatsbyjs.org/docs/\\\" target=\\\"_blank\\\">docs</a> to get started with gatsby and build my project. </p>\\n<p><img src=\\\"/images/github-reactsite.png\\\" alt=\\\"alt text\\\" title=\\\"Github react-site\\\"></p>\\n<p>After you build this sample project, a public folder is created, which contains the static files. Deployment can be done using S3 or any other hosting but i am using <strong>Apache Web server</strong> in <strong>DigitalOcean Ubuntu Droplet</strong> to host my project and we are going to automate the testing, build, integration and deployment.</p>\\n<p>If you want to learn hosting projects in Apache2 server then please follow this <a href=\\\"https://www.digitalocean.com/community/tutorials/how-to-set-up-apache-virtual-hosts-on-ubuntu-14-04-lts\\\" target=\\\"_blank\\\">link</a>.</p>\\n<h2>Steps to setup CI, CD.</h2>\\n<hr>\\n<h2>Docker</h2>\\n<p>Docker is a container management service. The keywords of Docker are <strong>develop, ship and run anywhere</strong>. The whole idea of Docker is for developers to easily develop applications, ship them into containers which can then be deployed anywhere. Docker has the ability to reduce the size of development by providing a smaller footprint of the operating system via containers.\\nWith containers, it becomes easier for teams across different units, such as development, QA and Operations to work seamlessly across applications. Docker containers are pretty lightweight, they are very easily scalable.</p>\\n<p><img src=\\\"/images/docker.png\\\" alt=\\\"alt text\\\" title=\\\"Docker\\\"></p>\\n<p>Please follow the official <a href=\\\"https://docs.docker.com/engine/installation/\\\" target=\\\"_blank\\\">docs</a> to install docker.</p>\\n<p>In our project we are using <a href=\\\"https://docs.docker.com/engine/reference/builder/\\\" target=\\\"_blank\\\">Dockerfile</a> to build <strong>Docker</strong> images.</p>\\n<p>Docker can build images automatically by reading the instructions from a <strong>Dockerfile</strong>. A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. Using docker build users can create an automated build that executes several command-line instructions in succession.</p>\\n<p>Dockerfile used in this prject is very simple and self explanatory. I am using <a href=\\\"https://docs.docker.com/engine/reference/builder/#run\\\" target=\\\"_blank\\\">RUN</a>, <a href=\\\"https://docs.docker.com/engine/reference/builder/#add\\\" target=\\\"_blank\\\">ADD</a>, <a href=\\\"https://docs.docker.com/engine/reference/builder/#copy\\\" target=\\\"_blank\\\">COPY</a> commands to initialize image.</p>\\n<p>Please note, if you want to keep any data persistent then you must use <a href=\\\"https://docs.docker.com/engine/reference/builder/#volume\\\" target=\\\"_blank\\\">VOLUME</a>. The <strong>VOLUME</strong> instruction creates a mount point with the specified name and marks it as holding externally mounted volumes from native host or other containers</p>\\n<p>You can build docker images locally using\\n<code>docker build --tag narendrasoni1989/react-site .</code></p>\\n<p>After docker image is built successfully, you can see it in the list by entering <code>docker images</code> in your terminal. </p>\\n<p>To see the list of running docker images, use <code>docker ps</code></p>\\n<p>If You can even push docker image from your local to docker hub.\\n<code>docker push narendrasoni1989/react-site</code></p>\\n<p>Docker push command requires you to be login using terminal <code>docker login</code>.</p>\\n<h2>TravisCI</h2>\\n<p>In the previous step we built docker image. Now this is manual process, for complex applications we don't want to do this step manually everytime. Fortunately we have solution to automate our build process. In this tutorial we are using <strong>TravisCI</strong>. It is very simple to setup, it hardly take few minutes to setup. All you need is a <code>.travis.yml</code> file and link your project in Github with TravisCI dashboard. If you make any changes in Github repository master branch, commit and push source code. TravisCI gets notified and triggers build processing using <code>.travis.yml</code> configuration file. Your <code>.travis.yml</code> file can be simple to complex, it completely depends on your usecase. </p>\\n<p><img src=\\\"/images/travisci.png\\\" alt=\\\"alt text\\\" title=\\\"TravisCi\\\"></p>\\n<p>In our project we are using a very simple <code>.travis.yml</code> configuration file. It is using Ubuntu distribution. On start of build process it installs <strong>docker</strong>, <strong>nodejs</strong>, it runs s sample unit test. If test is successful then it runs some after success script eg; <code>docker login</code>, <code>docker build</code> and <code>docker push</code>.\\nFeel free to customise <code>.travis.yml</code> file as per your usecase. You can use environment variables to be used in .travis.yml, so that you don't have to hardcode and push credentials to your repository. </p>\\n<p><img src=\\\"/images/travis-dashboard.png\\\" alt=\\\"alt text\\\" title=\\\"TravisCi\\\"></p>\\n<p>In the TravisCI portal make sure you switched on the repository to be hooked with Github. So that it can listen the change in repository.</p>\\n<h2>Docker Cloud</h2>\\n<p><a href=\\\"https://docs.docker.com/docker-cloud/\\\" target=\\\"_blank\\\">Docker Cloud</a> provides a hosted registry service with build and testing facilities for Dockerized application images; tools to help you set up and manage host infrastructure; and application lifecycle features to automate deploying (and redeploying) services created from images.</p>\\n<p><img src=\\\"/images/docker-cloud.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<p>So far we have automated the build process. Next task is to automate deployment. Are you doing good so far?</p>\\n<p>Before we move forward i will introduce you with some of the key terms that you will be hearing in this section.</p>\\n<blockquote>\\n<p><strong>Node</strong></p>\\n<ul>\\n<li>A node is an individual Linux host used to deploy and run your applications. Docker Cloud does not provide hosting services, so all of your applications, services, and containers run on your own hosts. Your hosts can come from several different sources, including physical servers, virtual machines or cloud providers.</li>\\n</ul>\\n</blockquote>\\n<blockquote>\\n<p><strong>Node Cluster</strong></p>\\n<ul>\\n<li>When launching a node from a cloud provider you’ll actually be creating a node cluster. Node Clusters are groups of nodes of the same type and from the same cloud provider. Node clusters allow you to scale the infrastructure by provisioning more nodes with a drag of a slider.</li>\\n</ul>\\n</blockquote>\\n<blockquote>\\n<p><strong>Service</strong></p>\\n<ul>\\n<li>Services are logical groups of containers from the same image. Services make it simple to scale your application across different nodes. In Docker Cloud you drag a slider to increase or decrease the availability, performance, and redundancy of the application. Services can also be linked one to another even if they are deployed on different nodes, regions, or even cloud providers.</li>\\n</ul>\\n</blockquote>\\n<p>Before you can do anything with your images, you need somewhere to run them. <strong>Docker Cloud</strong> allows you to link to your infrastructure or cloud services provider so you can provision new nodes automatically. Once you have nodes set up, you can deploy images directly from Docker Cloud repositories.</p>\\n<p>Next what we need to do is link our cloud service provider <a href=\\\"https://www.digitalocean.com\\\" target=\\\"_blank\\\">DigitalOcean</a> with Docker Cloud. Please follow this <a href=\\\"https://docs.docker.com/docker-cloud/infrastructure/link-do/\\\" target=\\\"_blank\\\">offical documentation </a> to learn about linking Digitalocean.\\n<strong>You will be getting 20$ credit as a bonus :)</strong> if you do so.</p>\\n<p>When you deploy a web service to multiple containers, you might want to load balance between the containers using a proxy or load balancer.</p>\\n<p>In this tutorial, you’ll use the <code>narendrasoni1989/react-site</code> image in docker cloud repository as a sample web service and dockercloud/haproxy to load balance traffic to the service. </p>\\n<p>Login to docker cloud, you will see docker image in your repository if your TravisCI build was successfull. We will be using only the image with tag <code>latest</code> for all our deployments.</p>\\n<h2>Create a node cluster</h2>\\n<ol>\\n<li>Click <code>Node Clusters</code> in the left-hand navigation menu.</li>\\n<li>Click <code>Create</code>.</li>\\n<li>Enter a name for the node cluster, select the *<strong>*Provider</strong>, <strong>Region</strong>, and <strong>Type/Size</strong>.</li>\\n<li>Add a deployment tag of <code>webexpressive</code>. (This is used to make sure the right services are deployed to the correct nodes.)</li>\\n<li>Drag or increment the Number of nodes slider to 1. If you increase it to more than 1 then you have to link your credit card and charges may apply so please keep it 1 if you are only doing it for learning.</li>\\n</ol>\\n<p><img src=\\\"/images/docker-cloud-dashboard-cluster.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<p><strong>Node Cluster</strong> takes about 5 minutes to deployed. You can check the timeline. After Cluster is successfully deployed you can check the details by clicking on the webexpressive cluster.</p>\\n<p><img src=\\\"/images/docker-cloud-dashboard-cluster1.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<h2>Launch the web service</h2>\\n<ol>\\n<li>Click Services in the left hand menu, and click Create.</li>\\n<li>Click the <code>my repositories</code> icon at the top of page, and select the <strong>narendrasoni1989/react-site</strong> image.</li>\\n</ol>\\n<p><img src=\\\"/images/docker-cloud-dashboard-service.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<ol start=\\\"3\\\">\\n<li>\\n<p>On the Service configuration screen, configure the service using these values:</p>\\n<ul>\\n<li><strong>Unordered sub-listimage</strong>: Set the tag to <code>latest</code> so you get the most recent build of the image.</li>\\n<li><strong>Service name</strong>: <code>webexpressive</code>. This is what we call the service internally.</li>\\n<li><strong>Number of containers</strong>: 2</li>\\n<li><strong>Deployment strategy</strong>: <code>high availability</code>. Deploy evenly to all nodes.</li>\\n<li><strong>Deployment constraints</strong>: <code>webexpressive</code>. Deploy only to nodes with this tag.</li>\\n</ul>\\n</li>\\n</ol>\\n<p><img src=\\\"/images/docker-cloud-dashboard-service1.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<ol start=\\\"4\\\">\\n<li>Enable AUTOREDEPLOY</li>\\n</ol>\\n<p><img src=\\\"/images/docker-cloud-dashboard-service2.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<ol start=\\\"5\\\">\\n<li>Last, scroll down to the Ports section and make sure the published box is checked next to port 80.\\nWe’re going to access these containers from the public internet, and publishing the port makes them available externally. Make sure you leave the node port field unset so that it stays dynamic.</li>\\n</ol>\\n<p><img src=\\\"/images/docker-cloud-dashboard-service3.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<ol start=\\\"6\\\">\\n<li>\\n<p>Click <strong>Create and deploy</strong>.\\nDocker Cloud switches to the Service detail view after you create the service.</p>\\n</li>\\n<li>\\n<p>Scroll up to the Containers section to see the containers as they deploy.\\nThe icons for each container change color to indicate what phase of deployment they’re in. Once all containers are green (successfully started), continue to the next step.</p>\\n</li>\\n</ol>\\n<p><img src=\\\"/images/docker-cloud-dashboard-service4.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<h2>Test the web service</h2>\\n<ol>\\n<li>\\n<p>Once your containers are all green (running), scroll down to the Endpoints section.</p>\\n<p>Here you’ll see a list of all the endpoints available for this service on the public internet.</p>\\n</li>\\n</ol>\\n<p><img src=\\\"/images/docker-cloud-dashboard-service5.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<ol start=\\\"2\\\">\\n<li>\\n<p>Click an endpoint URL (it should look something like\\n<code>http://webexpressive-1.fa8816e5.cont.dockerapp.io:32771</code>) to open a new tab in your browser.\\nIt should open up a webpage in your browser.</p>\\n</li>\\n<li>\\n<p>Click other endpoints and check the hostnames. You’ll see different hostnames which match the container name (webexpressive-2 and so on).</p>\\n</li>\\n</ol>\\n<h2>Launch the load balancer</h2>\\n<p>We verified that the web service is working, so now we’ll set up the load balancer.</p>\\n<ol>\\n<li>\\n<p>Click <code>Services</code> in the left navigation bar, and click Create again.\\nThis time we’ll launch a load balancer that listens on port 80 and balances the traffic across the 8 containers that are running the web service. </p>\\n</li>\\n<li>\\n<p>Click the <code>rocket icon</code> if necessary and find the Proxies section.</p>\\n</li>\\n<li>\\n<p>Click the <code>dockercloud/haproxy</code> image.</p>\\n</li>\\n</ol>\\n<p><img src=\\\"/images/docker-cloud-dashboard-service6.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<ol start=\\\"4\\\">\\n<li>\\n<p>On the next screen, configure the service using these values.</p>\\n<ul>\\n<li>Set the <strong>service name</strong> to <code>webexpressive-lb</code>.</li>\\n<li>Set the <strong>nick name</strong> to <code>webexpressive-lb</code>.</li>\\n<li>Set the <strong>deployment strategy</strong> to <code>High Availability</code>.</li>\\n</ul>\\n</li>\\n</ol>\\n<p><img src=\\\"/images/docker-cloud-dashboard-service7.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<ol start=\\\"5\\\">\\n<li>\\n<p>Set <code>API ROLES</code> to <code>Full access</code>\\nWhen you assign the service an API role, it passes a <code>DOCKERCLOUD_AUTH</code> environment variable to the service’s containers, which allows them to query Docker Cloud’s API on your behalf. You can read more about API Roles <a href=\\\"https://docs.docker.com/docker-cloud/apps/api-roles/\\\" target=\\\"_blank\\\">here</a>.</p>\\n<p>The dockercloud/haproxy image uses the API to check how many containers are in the web service we launched earlier. HAproxy then uses this information to update its configuration dynamically as the web service scales. </p>\\n</li>\\n<li>\\n<p>Next, scroll down to the Ports section.</p>\\n</li>\\n<li>\\n<p>Click the Published checkbox next to the container port 80.</p>\\n</li>\\n<li>\\n<p>Click the word dynamic next to port 80, and enter 80 to set the published port to also use port 80.</p>\\n</li>\\n</ol>\\n<p><img src=\\\"/images/docker-cloud-dashboard-service8.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<ol start=\\\"9\\\">\\n<li>\\n<p>Scroll down to the Links section.</p>\\n</li>\\n<li>\\n<p>Select <code>webexpressive</code> from the drop down list, and click the blue plus sign to add the link.</p>\\n<p>This links the load balancing service <code>webexpressive-lb</code> with the web service <code>webexpressive</code>. The link appears in the table in the Links section.</p>\\n</li>\\n</ol>\\n<pre><code>You’ll also notice that a new set of WEB environment variables appears in the service we’re about to launch. You can read more about service link environment variables &#x3C;a href=\\\"https://docs.docker.com/docker-cloud/apps/service-links/\\\" target=\\\"_blank\\\">here&#x3C;/a>.\\n</code></pre>\\n<p><img src=\\\"/images/docker-cloud-dashboard-service9.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<ol start=\\\"11\\\">\\n<li>Click <strong>Create and deploy</strong> and confirm that the service launches.</li>\\n</ol>\\n<h2>Test the load-balanced web service</h2>\\n<ol>\\n<li>\\n<p>On the load balancer service detail page, scroll down to the endpoints section.</p>\\n<p>Unlike on the web service, you’ll see that this time the HTTP URL for the load balancer is mapped to port 80.</p>\\n</li>\\n</ol>\\n<p><img src=\\\"/images/docker-cloud-dashboard-service10.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<ol start=\\\"2\\\">\\n<li>\\n<p>Click the endpoint URL to open it in a new tab.</p>\\n<p>You’ll see the same  webpage you saw earlier. Make note of the hostname.</p>\\n</li>\\n<li>\\n<p>Refresh the web page.</p>\\n<p>With each refresh, the hostname changes as the requests are load-balanced to different containers.</p>\\n<p>Each container in the web service has a different hostname, which appears in the webpage as <code>container_name-#</code>. When you refresh the page, the load balancer routes the request to a new host and the displayed hostname changes.</p>\\n</li>\\n</ol>\\n<p>Congratulations! You just deployed a load balanced web service using Docker Cloud!</p>\\n<h1>Further reading</h1>\\n<p>You did a great job. Continue reading the <a href=\\\"https://docs.docker.com/\\\" target=\\\"_blank\\\">official docs</a>, it is very well documented. We have only scratched the surface so far. You will encounter many more complex cases in real world scenario. This is good start, having this knowledge is going to help you. I encourage you to keep moving forward.</p>\\n<p>Next i would like recommend you to explore is <strong>load balancing the load balancer</strong>. What if you had so many <code>webexpressive</code> containers that you needed more than one <code>webexpressive-lb</code> container?</p>\\n<p>Docker Cloud automatically assigns a DNS endpoint to all services. This endpoint routes to all of the containers of that service. You can use the DNS endpoint to load balance your load balancer. To learn more, read up on <a href=\\\"https://docs.docker.com/docker-cloud/apps/service-links/\\\" target=\\\"_blank\\\">service links </a>.</p>\\n<p>I highly recommend you to learn the powerful container orchestration technologies such as <a href=\\\"https://docs.docker.com/engine/swarm/\\\" target=\\\"_blank\\\">Docker Swarm</a> and <a href=\\\"https://kubernetes.io/\\\" target=\\\"_blank\\\">Kubernetes</a> </p>\",\"frontmatter\":{\"layout\":\"post\",\"title\":\"Superfast CI,CD using Docker, TravisCI and DigitalOcean\",\"path\":\"/blog/superfast-CI-CD-using-docker-travisci-and-digitalocean/\",\"categories\":[\"devops\"],\"tags\":[\"digitalocean\",\"ci\",\"cd\",\"docker\",\"travisci\"],\"description\":\"Continuous integration focuses on integrating work from individual developers into a main repository multiple times a day to catch integration bugs early and accelerate collaborative development. Continuous delivery is concerned with reducing friction in the deployment or release process, automating the steps required to deploy a build so that code can be released safely at any time. Continuous deployment takes this one step further by automatically deploying each time a code change is made. In this guide, we will discuss each of these strategies and how we can achieve CI, CD using tools such as <a href=\\\"http://github.com\\\" target=\\\"_blank\\\"> Github </a>, <a href=\\\"https://www.docker.com\\\" target=\\\"_blank\\\">Docker</a>,<a href=\\\"https://travis-ci.org\\\" target=\\\"_blank\\\"> TravisCI</a>, <a href=\\\"https://cloud.docker.com\\\" target=\\\"_blank\\\">Docker Cloud</a> and <a href=\\\"https://www.digitalocean.com\\\" target=\\\"_blank\\\">DigitalOcean</a>.\",\"date\":\"2017/12/23\"}}}]}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---blog-8b4db292968afd4e1229.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Gatsby\",\"description\":\"Gatsby starter for bootstrap a blog\",\"url\":\"https://jaxx2104.github.io/gatsby-starter-bootstrap\",\"author\":\"Narendra\",\"twitter\":\"narendra\"}},\"remark\":{\"posts\":[{\"post\":{\"html\":\"<p>When starting out as a web developer, it can be easy to get lost in the multitude of languages, tools and platforms that are available in today’s market. However many would argue that GitHub is an essential platform for every web developer at every level.</p>\\n<p>GitHub was launched in April 2008 by Tom Preston-Werner, Chris Wanstrath, and PJ Hyett. At its base, it is a web platform, written in Ruby on Rails and Erlang, which hosts code repositories. But it also provides developers with an amazing toolset that makes it easy to follow certain coding best practices, all the while allowing you to get your name out there and show what you are capable of doing.</p>\\n<p>In this article, I will explain why GitHub is such an important tool for today’s web developer and how you can go about using it to get your name out there and advance your career in web development.</p>\\n<p><img src=\\\"/images/github.png\\\" alt=\\\"alt text\\\" title=\\\"Github\\\"></p>\\n<hr>\\n<h2>GitHub Makes Version Control Easier</h2>\\n<p>Few coding best practices are as prevalent as having some sort of Version Control for your code. Whether you are developing in Ruby, JavaScript, Python or any other language, a good Version Control workflow is essential and GitHub makes implementing that workflow easier by giving developers great tools with which to work.</p>\\n<p>As mentioned before, GitHub hosts Git repositories. Git is an immensely popular Version Control System, which allows developers to create a history of changes that occur over time in their code.</p>\\n<blockquote>\\n<p><strong>GitHub also adds several of its own functionalities to the ones offered by Git, such as::</strong></p>\\n<ul>\\n<li>A web-based graphical interface</li>\\n<li>A pastebin style site named Gist</li>\\n<li>Great tools for collaborating with other developers</li>\\n</ul>\\n</blockquote>\\n<h2>Graphical Interface</h2>\\n<p>Git is very powerful, but it can only be used in the terminal, which can be daunting for many developers, especially new developers. Viewing logs and differentials between commits can be very difficult to do in a purely command-prompt interface.</p>\\n<p>GitHub creates an intuitive and powerful graphical interface for the Git versioning system. You can easily see your repositories and browse through its list of commits. If you want to see the changes made in one of your commits, it is as simple as clicking on the commit from the list and GitHub will present you with the differential. Much simpler than typing commands in your terminal and deciphering their results.</p>\\n<p>Above is an example from a user in GitHub.</p>\\n<p>Create a profile, upload some code and see how things are laid out, it is very user friendly and intuitive.</p>\\n<h2>Gist</h2>\\n<p>Pastebin applications allow users to store plain text. They are commonly used by developers to store and share small scripts and bits of codes. Gist was created by GitHub as a Pastebin-style application, but Gists also benefit from Version Control.</p>\\n<p>Each Gist is essentially a mini-project, it has its own Git repository, which allows users to store multiple bits of code and also allows them to track changes within their Gist, without needing to commit them manually.</p>\\n<p>Gist are by default public, to make it easier to share, but they can also be marked as private, allowing only you to access them.</p>\\n<h2>Collaboration Tools</h2>\\n<p>Github also introduces many collaboration tools, some of which are listed below, which make it easier for developers to work together on a project.</p>\\n<ol>\\n<li>GitHub allows you to create access rights to your code which means, for example, you could designate certain users who are allowed to freely push code to your repository.</li>\\n<li>GitHub’s Forking feature allows a user to create a copy of a repository on their computer for them to work on without affecting the main repository. They can modify the code and then request to have the code merged with the main repository using another feature called Pull Requests.</li>\\n<li>Pull Requests are a way for you to tell other developers about the changes you wish to merge into the main repository. The repository’s authors can review your changes and engage in discussions about them. Should more changes be needed, you can simply continue to work in your fork and the additional commits will appear in the pull request. Once a Pull Request is approved, the changes can then be merged into the main repository by the project’s author.</li>\\n<li>GitHub also has Issues for repositories. Issues are a great way to keep track of bugs in your code, but you can also use it to keep track of tasks and other enhancements you would like to implement in your code. Issues are very powerful and mastering them is a great way to keep yourself organised. For more information on Issues, please see this guide posted on GitHub’s website.</li>\\n</ol>\\n<h2>GitHub Is The Place To Be For Open Source</h2>\\n<p>With so many great tools available to developers, GitHub has become the place to be for open source software. Some of the biggest open source projects are hosted on GitHub, such as Ruby on Rails, AngularJS, Bootstrap and many many more. There are even some big tech companies, like Microsoft, who maintain code repositories on GitHub.</p>\\n<p>The collaboration features mentioned above make it easy for any developer to get involved with their favorite open source project.</p>\\n<p>GitHub also allows you to keep an eye on your favorite developers by following them or your favorite project by “watching” it. There are many ways to be social on GitHub, so don’t hesitate to go exploring and see what is happening in the world of software development.</p>\\n<h2>Using GitHub To Showcase Your Skills</h2>\\n<p>As we have mentioned above, GitHub is a great tool to make Version Control easier and it’s a site that is used for some of the biggest projects out there. But perhaps it’s biggest asset is the fact that it is a great way to showcase your skills.</p>\\n<p>A GitHub profile that features real world projects and shows contributions to open source projects is a great way to display exactly what you are capable of doing to prospective employers.</p>\\n<p>When applying to developer positions, employers are looking for people who have experience programming and who program well. You can direct prospective employers to your GitHub profile, which can act as your portfolio. Employers can then:</p>\\n<ul>\\n<li>view your code</li>\\n<li>see how you think</li>\\n<li>understand how you solved particular problems</li>\\n<li>see whether or not you would be a good fit for their organization. Your open source contributions can also show potential employers that you are versatile and can easily adapt and contribute to various projects, something that is essential when working as a web developer.</li>\\n</ul>\\n<p>Having a fully fleshed out and varied GitHub profile is a great way to stand out as a web developer in today’s market.</p>\\n<p>GitHub has become one of the few necessary platforms to use in today’s web development world. It is a great tool that makes your life easier, has the potential to make you stand out from other web developers and hosts some of the biggest and most interesting projects out there today. So I recommend you go out and explore the various projects on GitHub and start contributing to your favourite ones.</p>\\n<p>Interested in launching a career in web development? Don’t forget to check out CareerFoundry’s Web Development Course too.\\nHappy coding!</p>\",\"frontmatter\":{\"layout\":\"post\",\"title\":\"The Importance of GitHub for Web Developers\",\"path\":\"/blog/importance-of-github-for-web-developers/\",\"categories\":[\"programming\",\"software-development\"],\"tags\":[\"developers\",\"web-developers\",\"github\"],\"description\":\"GitHub was launched in April 2008 by Tom Preston-Werner, Chris Wanstrath, and PJ Hyett. At its base, it is a web platform, written in Ruby on Rails and Erlang, which hosts code repositories. But it also provides developers with an amazing toolset that makes it easy to follow certain coding best practices, all the while allowing you to get your name out there and show what you are capable of doing.\",\"date\":\"2017/12/19\"}}},{\"post\":{\"html\":\"<p>In this guide, i will be taking you through the complete process of setting up CI,CD using <a href=\\\"http://github.com\\\" target=\\\"_blank\\\"> Github </a>, <a href=\\\"https://www.docker.com\\\" target=\\\"_blank\\\">Docker</a>, <a href=\\\"https://travis-ci.org\\\" target=\\\"_blank\\\"> TravisCI</a>, <a href=\\\"https://cloud.docker.com\\\" target=\\\"_blank\\\">Docker Cloud</a> and <a href=\\\"https://www.digitalocean.com\\\" target=\\\"_blank\\\">DigitalOcean</a>.\\nIf you are not familiar with CI/CD then i highly encourage you to please go through <a href=\\\"https://www.digitalocean.com/community/tutorials/an-introduction-to-continuous-integration-delivery-and-deployment\\\" target=\\\"_blank\\\">this</a> article. Once you have basic idea about CI/CD, i promise you that you will be successful in automating your build and deployment process.</p>\\n<p>I assume you have accounts in <a href=\\\"http://github.com\\\" target=\\\"_blank\\\"> Github </a>, <a href=\\\"https://travis-ci.org\\\" target=\\\"_blank\\\"> TravisCI</a>, <a href=\\\"https://cloud.docker.com\\\" target=\\\"_blank\\\">Docker Cloud</a> and <a href=\\\"https://www.digitalocean.com\\\" target=\\\"_blank\\\">DigitalOcean</a>. In case you don't have accounts yet then please create one. I am using <strong>DigitalOcean</strong> for running docker nodes and servies. DigitalOcean offers all the necessary services at reasonable price for running production apps. You can go with the very basic <strong>Ubuntu 16.04.3 x64 $5/mo droplet</strong>, it will give you <strong>512mb/1CPU 20GB SSD hard disk</strong>, which is good enough for running our app.</p>\\n<p>You can follow <a href=\\\"https://www.wikihow.com/Create-an-Account-on-GitHub\\\" target=\\\"_blank\\\">these steps</a> to create an account in <strong>Github</strong>.</p>\\n<p><strong>Travis CI</strong> is a hosted, distributed continuous integration service used to build and test software projects hosted at GitHub. Open source projects may be tested at no charge via <a href=\\\"https://travis-ci.org\\\">https://travis-ci.org</a> . </p>\\n<p><img src=\\\"/images/ci-cd.png\\\" alt=\\\"alt text\\\" title=\\\"CI/CD\\\"></p>\\n<p>In this guide i am using my <a href=\\\"https://github.com/narendrasoni1989/react-site\\\" target=\\\"_blank\\\">sample portfolio project </a>hosted in Github. It is developed using revolutionary high performance site generator framework <a href=\\\"https://www.gatsbyjs.org/\\\" target=\\\"_blank\\\">GatsbyJs</a>. It's an amazing platform if you want to build your application. It is based on <a href=\\\"https://jamstack.org/\\\" target=\\\"_blank\\\">JAMStack</a>. Do checkout if you are interested to build your portfolio. Feel free to use my sourcecode if you are interested. To Please follow the <a href=\\\"https://www.gatsbyjs.org/docs/\\\" target=\\\"_blank\\\">docs</a> to get started with gatsby and build my project. </p>\\n<p><img src=\\\"/images/github-reactsite.png\\\" alt=\\\"alt text\\\" title=\\\"Github react-site\\\"></p>\\n<p>After you build this sample project, a public folder is created, which contains the static files. Deployment can be done using S3 or any other hosting but i am using <strong>Apache Web server</strong> in <strong>DigitalOcean Ubuntu Droplet</strong> to host my project and we are going to automate the testing, build, integration and deployment.</p>\\n<p>If you want to learn hosting projects in Apache2 server then please follow this <a href=\\\"https://www.digitalocean.com/community/tutorials/how-to-set-up-apache-virtual-hosts-on-ubuntu-14-04-lts\\\" target=\\\"_blank\\\">link</a>.</p>\\n<h2>Steps to setup CI, CD.</h2>\\n<hr>\\n<h2>Docker</h2>\\n<p>Docker is a container management service. The keywords of Docker are <strong>develop, ship and run anywhere</strong>. The whole idea of Docker is for developers to easily develop applications, ship them into containers which can then be deployed anywhere. Docker has the ability to reduce the size of development by providing a smaller footprint of the operating system via containers.\\nWith containers, it becomes easier for teams across different units, such as development, QA and Operations to work seamlessly across applications. Docker containers are pretty lightweight, they are very easily scalable.</p>\\n<p><img src=\\\"/images/docker.png\\\" alt=\\\"alt text\\\" title=\\\"Docker\\\"></p>\\n<p>Please follow the official <a href=\\\"https://docs.docker.com/engine/installation/\\\" target=\\\"_blank\\\">docs</a> to install docker.</p>\\n<p>In our project we are using <a href=\\\"https://docs.docker.com/engine/reference/builder/\\\" target=\\\"_blank\\\">Dockerfile</a> to build <strong>Docker</strong> images.</p>\\n<p>Docker can build images automatically by reading the instructions from a <strong>Dockerfile</strong>. A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. Using docker build users can create an automated build that executes several command-line instructions in succession.</p>\\n<p>Dockerfile used in this prject is very simple and self explanatory. I am using <a href=\\\"https://docs.docker.com/engine/reference/builder/#run\\\" target=\\\"_blank\\\">RUN</a>, <a href=\\\"https://docs.docker.com/engine/reference/builder/#add\\\" target=\\\"_blank\\\">ADD</a>, <a href=\\\"https://docs.docker.com/engine/reference/builder/#copy\\\" target=\\\"_blank\\\">COPY</a> commands to initialize image.</p>\\n<p>Please note, if you want to keep any data persistent then you must use <a href=\\\"https://docs.docker.com/engine/reference/builder/#volume\\\" target=\\\"_blank\\\">VOLUME</a>. The <strong>VOLUME</strong> instruction creates a mount point with the specified name and marks it as holding externally mounted volumes from native host or other containers</p>\\n<p>You can build docker images locally using\\n<code>docker build --tag narendrasoni1989/react-site .</code></p>\\n<p>After docker image is built successfully, you can see it in the list by entering <code>docker images</code> in your terminal. </p>\\n<p>To see the list of running docker images, use <code>docker ps</code></p>\\n<p>If You can even push docker image from your local to docker hub.\\n<code>docker push narendrasoni1989/react-site</code></p>\\n<p>Docker push command requires you to be login using terminal <code>docker login</code>.</p>\\n<h2>TravisCI</h2>\\n<p>In the previous step we built docker image. Now this is manual process, for complex applications we don't want to do this step manually everytime. Fortunately we have solution to automate our build process. In this tutorial we are using <strong>TravisCI</strong>. It is very simple to setup, it hardly take few minutes to setup. All you need is a <code>.travis.yml</code> file and link your project in Github with TravisCI dashboard. If you make any changes in Github repository master branch, commit and push source code. TravisCI gets notified and triggers build processing using <code>.travis.yml</code> configuration file. Your <code>.travis.yml</code> file can be simple to complex, it completely depends on your usecase. </p>\\n<p><img src=\\\"/images/travisci.png\\\" alt=\\\"alt text\\\" title=\\\"TravisCi\\\"></p>\\n<p>In our project we are using a very simple <code>.travis.yml</code> configuration file. It is using Ubuntu distribution. On start of build process it installs <strong>docker</strong>, <strong>nodejs</strong>, it runs s sample unit test. If test is successful then it runs some after success script eg; <code>docker login</code>, <code>docker build</code> and <code>docker push</code>.\\nFeel free to customise <code>.travis.yml</code> file as per your usecase. You can use environment variables to be used in .travis.yml, so that you don't have to hardcode and push credentials to your repository. </p>\\n<p><img src=\\\"/images/travis-dashboard.png\\\" alt=\\\"alt text\\\" title=\\\"TravisCi\\\"></p>\\n<p>In the TravisCI portal make sure you switched on the repository to be hooked with Github. So that it can listen the change in repository.</p>\\n<h2>Docker Cloud</h2>\\n<p><a href=\\\"https://docs.docker.com/docker-cloud/\\\" target=\\\"_blank\\\">Docker Cloud</a> provides a hosted registry service with build and testing facilities for Dockerized application images; tools to help you set up and manage host infrastructure; and application lifecycle features to automate deploying (and redeploying) services created from images.</p>\\n<p><img src=\\\"/images/docker-cloud.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<p>So far we have automated the build process. Next task is to automate deployment. Are you doing good so far?</p>\\n<p>Before we move forward i will introduce you with some of the key terms that you will be hearing in this section.</p>\\n<blockquote>\\n<p><strong>Node</strong></p>\\n<ul>\\n<li>A node is an individual Linux host used to deploy and run your applications. Docker Cloud does not provide hosting services, so all of your applications, services, and containers run on your own hosts. Your hosts can come from several different sources, including physical servers, virtual machines or cloud providers.</li>\\n</ul>\\n</blockquote>\\n<blockquote>\\n<p><strong>Node Cluster</strong></p>\\n<ul>\\n<li>When launching a node from a cloud provider you’ll actually be creating a node cluster. Node Clusters are groups of nodes of the same type and from the same cloud provider. Node clusters allow you to scale the infrastructure by provisioning more nodes with a drag of a slider.</li>\\n</ul>\\n</blockquote>\\n<blockquote>\\n<p><strong>Service</strong></p>\\n<ul>\\n<li>Services are logical groups of containers from the same image. Services make it simple to scale your application across different nodes. In Docker Cloud you drag a slider to increase or decrease the availability, performance, and redundancy of the application. Services can also be linked one to another even if they are deployed on different nodes, regions, or even cloud providers.</li>\\n</ul>\\n</blockquote>\\n<p>Before you can do anything with your images, you need somewhere to run them. <strong>Docker Cloud</strong> allows you to link to your infrastructure or cloud services provider so you can provision new nodes automatically. Once you have nodes set up, you can deploy images directly from Docker Cloud repositories.</p>\\n<p>Next what we need to do is link our cloud service provider <a href=\\\"https://www.digitalocean.com\\\" target=\\\"_blank\\\">DigitalOcean</a> with Docker Cloud. Please follow this <a href=\\\"https://docs.docker.com/docker-cloud/infrastructure/link-do/\\\" target=\\\"_blank\\\">offical documentation </a> to learn about linking Digitalocean.\\n<strong>You will be getting 20$ credit as a bonus :)</strong> if you do so.</p>\\n<p>When you deploy a web service to multiple containers, you might want to load balance between the containers using a proxy or load balancer.</p>\\n<p>In this tutorial, you’ll use the <code>narendrasoni1989/react-site</code> image in docker cloud repository as a sample web service and dockercloud/haproxy to load balance traffic to the service. </p>\\n<p>Login to docker cloud, you will see docker image in your repository if your TravisCI build was successfull. We will be using only the image with tag <code>latest</code> for all our deployments.</p>\\n<h2>Create a node cluster</h2>\\n<ol>\\n<li>Click <code>Node Clusters</code> in the left-hand navigation menu.</li>\\n<li>Click <code>Create</code>.</li>\\n<li>Enter a name for the node cluster, select the *<strong>*Provider</strong>, <strong>Region</strong>, and <strong>Type/Size</strong>.</li>\\n<li>Add a deployment tag of <code>webexpressive</code>. (This is used to make sure the right services are deployed to the correct nodes.)</li>\\n<li>Drag or increment the Number of nodes slider to 1. If you increase it to more than 1 then you have to link your credit card and charges may apply so please keep it 1 if you are only doing it for learning.</li>\\n</ol>\\n<p><img src=\\\"/images/docker-cloud-dashboard-cluster.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<p><strong>Node Cluster</strong> takes about 5 minutes to deployed. You can check the timeline. After Cluster is successfully deployed you can check the details by clicking on the webexpressive cluster.</p>\\n<p><img src=\\\"/images/docker-cloud-dashboard-cluster1.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<h2>Launch the web service</h2>\\n<ol>\\n<li>Click Services in the left hand menu, and click Create.</li>\\n<li>Click the <code>my repositories</code> icon at the top of page, and select the <strong>narendrasoni1989/react-site</strong> image.</li>\\n</ol>\\n<p><img src=\\\"/images/docker-cloud-dashboard-service.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<ol start=\\\"3\\\">\\n<li>\\n<p>On the Service configuration screen, configure the service using these values:</p>\\n<ul>\\n<li><strong>Unordered sub-listimage</strong>: Set the tag to <code>latest</code> so you get the most recent build of the image.</li>\\n<li><strong>Service name</strong>: <code>webexpressive</code>. This is what we call the service internally.</li>\\n<li><strong>Number of containers</strong>: 2</li>\\n<li><strong>Deployment strategy</strong>: <code>high availability</code>. Deploy evenly to all nodes.</li>\\n<li><strong>Deployment constraints</strong>: <code>webexpressive</code>. Deploy only to nodes with this tag.</li>\\n</ul>\\n</li>\\n</ol>\\n<p><img src=\\\"/images/docker-cloud-dashboard-service1.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<ol start=\\\"4\\\">\\n<li>Enable AUTOREDEPLOY</li>\\n</ol>\\n<p><img src=\\\"/images/docker-cloud-dashboard-service2.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<ol start=\\\"5\\\">\\n<li>Last, scroll down to the Ports section and make sure the published box is checked next to port 80.\\nWe’re going to access these containers from the public internet, and publishing the port makes them available externally. Make sure you leave the node port field unset so that it stays dynamic.</li>\\n</ol>\\n<p><img src=\\\"/images/docker-cloud-dashboard-service3.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<ol start=\\\"6\\\">\\n<li>\\n<p>Click <strong>Create and deploy</strong>.\\nDocker Cloud switches to the Service detail view after you create the service.</p>\\n</li>\\n<li>\\n<p>Scroll up to the Containers section to see the containers as they deploy.\\nThe icons for each container change color to indicate what phase of deployment they’re in. Once all containers are green (successfully started), continue to the next step.</p>\\n</li>\\n</ol>\\n<p><img src=\\\"/images/docker-cloud-dashboard-service4.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<h2>Test the web service</h2>\\n<ol>\\n<li>\\n<p>Once your containers are all green (running), scroll down to the Endpoints section.</p>\\n<p>Here you’ll see a list of all the endpoints available for this service on the public internet.</p>\\n</li>\\n</ol>\\n<p><img src=\\\"/images/docker-cloud-dashboard-service5.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<ol start=\\\"2\\\">\\n<li>\\n<p>Click an endpoint URL (it should look something like\\n<code>http://webexpressive-1.fa8816e5.cont.dockerapp.io:32771</code>) to open a new tab in your browser.\\nIt should open up a webpage in your browser.</p>\\n</li>\\n<li>\\n<p>Click other endpoints and check the hostnames. You’ll see different hostnames which match the container name (webexpressive-2 and so on).</p>\\n</li>\\n</ol>\\n<h2>Launch the load balancer</h2>\\n<p>We verified that the web service is working, so now we’ll set up the load balancer.</p>\\n<ol>\\n<li>\\n<p>Click <code>Services</code> in the left navigation bar, and click Create again.\\nThis time we’ll launch a load balancer that listens on port 80 and balances the traffic across the 8 containers that are running the web service. </p>\\n</li>\\n<li>\\n<p>Click the <code>rocket icon</code> if necessary and find the Proxies section.</p>\\n</li>\\n<li>\\n<p>Click the <code>dockercloud/haproxy</code> image.</p>\\n</li>\\n</ol>\\n<p><img src=\\\"/images/docker-cloud-dashboard-service6.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<ol start=\\\"4\\\">\\n<li>\\n<p>On the next screen, configure the service using these values.</p>\\n<ul>\\n<li>Set the <strong>service name</strong> to <code>webexpressive-lb</code>.</li>\\n<li>Set the <strong>nick name</strong> to <code>webexpressive-lb</code>.</li>\\n<li>Set the <strong>deployment strategy</strong> to <code>High Availability</code>.</li>\\n</ul>\\n</li>\\n</ol>\\n<p><img src=\\\"/images/docker-cloud-dashboard-service7.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<ol start=\\\"5\\\">\\n<li>\\n<p>Set <code>API ROLES</code> to <code>Full access</code>\\nWhen you assign the service an API role, it passes a <code>DOCKERCLOUD_AUTH</code> environment variable to the service’s containers, which allows them to query Docker Cloud’s API on your behalf. You can read more about API Roles <a href=\\\"https://docs.docker.com/docker-cloud/apps/api-roles/\\\" target=\\\"_blank\\\">here</a>.</p>\\n<p>The dockercloud/haproxy image uses the API to check how many containers are in the web service we launched earlier. HAproxy then uses this information to update its configuration dynamically as the web service scales. </p>\\n</li>\\n<li>\\n<p>Next, scroll down to the Ports section.</p>\\n</li>\\n<li>\\n<p>Click the Published checkbox next to the container port 80.</p>\\n</li>\\n<li>\\n<p>Click the word dynamic next to port 80, and enter 80 to set the published port to also use port 80.</p>\\n</li>\\n</ol>\\n<p><img src=\\\"/images/docker-cloud-dashboard-service8.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<ol start=\\\"9\\\">\\n<li>\\n<p>Scroll down to the Links section.</p>\\n</li>\\n<li>\\n<p>Select <code>webexpressive</code> from the drop down list, and click the blue plus sign to add the link.</p>\\n<p>This links the load balancing service <code>webexpressive-lb</code> with the web service <code>webexpressive</code>. The link appears in the table in the Links section.</p>\\n</li>\\n</ol>\\n<pre><code>You’ll also notice that a new set of WEB environment variables appears in the service we’re about to launch. You can read more about service link environment variables &#x3C;a href=\\\"https://docs.docker.com/docker-cloud/apps/service-links/\\\" target=\\\"_blank\\\">here&#x3C;/a>.\\n</code></pre>\\n<p><img src=\\\"/images/docker-cloud-dashboard-service9.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<ol start=\\\"11\\\">\\n<li>Click <strong>Create and deploy</strong> and confirm that the service launches.</li>\\n</ol>\\n<h2>Test the load-balanced web service</h2>\\n<ol>\\n<li>\\n<p>On the load balancer service detail page, scroll down to the endpoints section.</p>\\n<p>Unlike on the web service, you’ll see that this time the HTTP URL for the load balancer is mapped to port 80.</p>\\n</li>\\n</ol>\\n<p><img src=\\\"/images/docker-cloud-dashboard-service10.png\\\" alt=\\\"alt text\\\" title=\\\"Docker Cloud\\\"></p>\\n<ol start=\\\"2\\\">\\n<li>\\n<p>Click the endpoint URL to open it in a new tab.</p>\\n<p>You’ll see the same  webpage you saw earlier. Make note of the hostname.</p>\\n</li>\\n<li>\\n<p>Refresh the web page.</p>\\n<p>With each refresh, the hostname changes as the requests are load-balanced to different containers.</p>\\n<p>Each container in the web service has a different hostname, which appears in the webpage as <code>container_name-#</code>. When you refresh the page, the load balancer routes the request to a new host and the displayed hostname changes.</p>\\n</li>\\n</ol>\\n<p>Congratulations! You just deployed a load balanced web service using Docker Cloud!</p>\\n<h1>Further reading</h1>\\n<p>You did a great job. Continue reading the <a href=\\\"https://docs.docker.com/\\\" target=\\\"_blank\\\">official docs</a>, it is very well documented. We have only scratched the surface so far. You will encounter many more complex cases in real world scenario. This is good start, having this knowledge is going to help you. I encourage you to keep moving forward.</p>\\n<p>Next i would like recommend you to explore is <strong>load balancing the load balancer</strong>. What if you had so many <code>webexpressive</code> containers that you needed more than one <code>webexpressive-lb</code> container?</p>\\n<p>Docker Cloud automatically assigns a DNS endpoint to all services. This endpoint routes to all of the containers of that service. You can use the DNS endpoint to load balance your load balancer. To learn more, read up on <a href=\\\"https://docs.docker.com/docker-cloud/apps/service-links/\\\" target=\\\"_blank\\\">service links </a>.</p>\\n<p>I highly recommend you to learn the powerful container orchestration technologies such as <a href=\\\"https://docs.docker.com/engine/swarm/\\\" target=\\\"_blank\\\">Docker Swarm</a> and <a href=\\\"https://kubernetes.io/\\\" target=\\\"_blank\\\">Kubernetes</a> </p>\",\"frontmatter\":{\"layout\":\"post\",\"title\":\"Superfast CI,CD using Docker, TravisCI and DigitalOcean\",\"path\":\"/blog/superfast-CI-CD-using-docker-travisci-and-digitalocean/\",\"categories\":[\"devops\"],\"tags\":[\"digitalocean\",\"ci\",\"cd\",\"docker\",\"travisci\"],\"description\":\"Continuous integration focuses on integrating work from individual developers into a main repository multiple times a day to catch integration bugs early and accelerate collaborative development. Continuous delivery is concerned with reducing friction in the deployment or release process, automating the steps required to deploy a build so that code can be released safely at any time. Continuous deployment takes this one step further by automatically deploying each time a code change is made. In this guide, we will discuss each of these strategies and how we can achieve CI, CD using tools such as <a href=\\\"http://github.com\\\" target=\\\"_blank\\\"> Github </a>, <a href=\\\"https://www.docker.com\\\" target=\\\"_blank\\\">Docker</a>,<a href=\\\"https://travis-ci.org\\\" target=\\\"_blank\\\"> TravisCI</a>, <a href=\\\"https://cloud.docker.com\\\" target=\\\"_blank\\\">Docker Cloud</a> and <a href=\\\"https://www.digitalocean.com\\\" target=\\\"_blank\\\">DigitalOcean</a>.\",\"date\":\"2017/12/23\"}}}]}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/blog.json\n// module id = 532\n// module chunks = 49683490770531"],"sourceRoot":""}